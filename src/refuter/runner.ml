(*
"create_params_and_storages_from_model" requires some implicit MicSE design decisions.
1. "Prover.Converter.create_rename_var" uses the prefix "#" to generate new symbol of existing variable.
2. It uses some magic-names from "Pre.Lib.Cfg.param_storage_name" and "Refuter.Extractor.trx_seq_param_name" and "Refuter.Extractor.trx_seq_storage_name"
3. It almost follows implementation of the function "Prover.Verifier.create_param_storage_from_model"
*)

(*
let create_params_and_storages_from_model : Prover.Lib.Smt.model -> Pre.Lib.Cfg.t -> (string * Prover.Lib.Smt.z_expr) list
= let open Pre.Lib in
  let open Prover.Lib in
  fun trx_length m cfg -> begin
  let param_storage_var = Cfg.param_storage_name in
  let param_storage_sort = Prover.Verifier.sort_of_typt (Pre.Lib.Cfg.CPMap.find_exn cfg.type_info param_storage_var) in
  let param_storage = Smt.read_var (Smt.create_symbol param_storage_var) param_storage_sort in
  let param, storage = ((Smt.read_pair_fst param_storage), (Smt.read_pair_snd param_storage)) in
  let param_expr_opt, storage_expr_opt = ((Smt.create_evaluation m param), (Smt.create_evaluation m storage)) in
  let paramstg_added : (string * Smt.z_expr) list = (
    match (param_expr_opt, storage_expr_opt) with
    | Some param_expr, Some storage_expr -> ["param", param_expr; "storage", storage_expr]
    | _, _ -> Stdlib.failwith "Refuter : Runner : create_params_and_storages_from_model : paramstg_added"
  ) in
  ()
end
*)

(* input
    - cfg
    - basicpaths (generated by Refuter.Extractor.get_concatenated_basicpaths)
    - queryfilter (function that removes unwanted queries)
*)
let collect_queries : PreLib.Cfg.t -> (Prover.Lib.Bp.t list) -> (Prover.Lib.Query.t list -> Prover.Lib.Query.t list) -> (Prover.Lib.Query.t list)
=fun cfg bplist queryfilter -> begin
  let queryll : Prover.Lib.Query.t list list = List.map (fun bp -> Prover.Converter.convert bp cfg |> Stdlib.snd) bplist in
  List.flatten (List.map queryfilter queryll)
end
